Here you go ‚Äî **the most complete, interview-focused list of DSA patterns**.
This is the master list used by top LeetCode/FAANG learners.
No filler. No useless CP-only patterns.
Just what actually matters.

---

# üî• **DSA PATTERN MASTER LIST (40+ Patterns)**

### **A. Arrays & Basic Patterns**

1. Prefix Sum
2. Suffix Sum
3. Difference Array
4. Sliding Window (Fixed Size)
5. Sliding Window (Variable Size)
6. Two Pointers (Opposite Direction)
7. Two Pointers (Same Direction)
8. Fast & Slow Pointers (Floyd cycle)
9. Sorting + Greedy
10. Sweep Line Technique
11. Meet-in-the-Middle

---

# üî• **B. Hashing & Frequency Patterns**

12. HashMap Counting
13. HashSet Distinct Tracking
14. Frequency Map + Sliding Window
15. Prefix Sum + HashMap (Subarray sums)
16. Modulo Frequency (divisible subarrays)

---

# üî• **C. Stack / Queue Patterns**

17. Monotonic Increasing Stack
18. Monotonic Decreasing Stack
19. Next Greater / Smaller Element
20. Stack Simulation
21. Min/Max Queue
22. Monotonic Queue (for sliding window maximum)

---

# üî• **D. Binary Search Patterns**

23. Binary Search on Sorted Array
24. Binary Search on Answer / Decision Problems
25. Lower Bound / Upper Bound
26. Binary Search in Rotated Array
27. Ternary Search (rare, but useful)

---

# üî• **E. Recursion / Backtracking Patterns**

28. Subsets
29. Permutations
30. Combination Sum variations
31. N-Queens
32. Backtracking with pruning
33. DFS-building strings / numbers

---

# üî• **F. Dynamic Programming Patterns**

34. DP on Arrays (Knapsack, House Robber)
35. DP on Subsequences (LIS, LCS)
36. DP on Strings (Edit distance)
37. DP on Grids (Paths, obstacles)
38. Palindromic DP (LPS, partitions)
39. Bitmask DP
40. DP with Prefix Optimization
41. DP with Binary Search (LIS O(n log n))
42. DP on Trees

---

# üî• **G. Graph Patterns**

43. BFS (Level order, shortest path unweighted)
44. DFS (connected components, recursion)
45. Topological Sort
46. Kahn's Algorithm
47. Cycle Detection (directed/undirected)
48. Bipartite Check
49. Dijkstra (shortest path weighted)
50. Bellman-Ford
51. Floyd-Warshall
52. Prim‚Äôs Algorithm
53. Kruskal‚Äôs (DSU)
54. Bridges & Articulation Points
55. Strongly Connected Components (Kosaraju / Tarjan)

---

# üî• **H. Tree Patterns**

56. DFS Traversals
57. BFS Traversals
58. Binary Tree Recursion
59. Boundary Traversal
60. Lowest Common Ancestor
61. Diameter of Tree
62. Tree DP
63. Binary Search Tree (inorder properties)

---

# üî• **I. Advanced/Useful Patterns**

64. Trie (Prefix tree)
65. Segment Tree (range query/update)
66. Fenwick Tree (BIT)
67. Sweep Line + Events
68. Intervals Merging
69. Greedy with Heap
70. Meet-in-the-middle
71. Deque Optimization
72. Binary Lifting
73. Sparse Table (RMQ)
74. Sliding Window + Hashmap hybrid
75. Prefix Min/Max techniques

---

# üî• **J. Math/Bitwise Patterns**

76. Bitmasking
77. Bitwise Tricks (xor, parity)
78. Sieve of Eratosthenes
79. Prime Factorization pattern
80. Modular Arithmetic
81. Fast Exponentiation

---

# ‚≠ê **This is the complete pattern ecosystem that covers 99% of interview problems.**

If you master even **20 of these**, you're interview-ready.
If you master **all 80**, you reach competitive programming level.

